// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApiKey = `-- name: CreateApiKey :one

INSERT INTO api_keys (
  id, key_hash, customer_id, created_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, customer_id, key_hash, revoked_at, last_used_at, created_at
`

type CreateApiKeyParams struct {
	ID         pgtype.UUID
	KeyHash    string
	CustomerID pgtype.UUID
	CreatedAt  pgtype.Timestamp
}

// API Keys
func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ModelApiKey, error) {
	row := q.db.QueryRow(ctx, createApiKey,
		arg.ID,
		arg.KeyHash,
		arg.CustomerID,
		arg.CreatedAt,
	)
	var i ModelApiKey
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.KeyHash,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one

INSERT INTO customers (
  id, name, business_identifier, created_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, name, business_identifier, created_at, modified_at, deleted_at
`

type CreateCustomerParams struct {
	ID                 pgtype.UUID
	Name               string
	BusinessIdentifier string
	CreatedAt          pgtype.Timestamp
}

// Customers
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (ModelCustomer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.ID,
		arg.Name,
		arg.BusinessIdentifier,
		arg.CreatedAt,
	)
	var i ModelCustomer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BusinessIdentifier,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOptimization = `-- name: CreateOptimization :one

INSERT INTO optimizations (
  id, customer_id, kind, created_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, customer_id, kind, created_at
`

type CreateOptimizationParams struct {
	ID         pgtype.UUID
	CustomerID pgtype.UUID
	Kind       RequestKind
	CreatedAt  pgtype.Timestamp
}

// Optimizations
func (q *Queries) CreateOptimization(ctx context.Context, arg CreateOptimizationParams) (Optimization, error) {
	row := q.db.QueryRow(ctx, createOptimization,
		arg.ID,
		arg.CustomerID,
		arg.Kind,
		arg.CreatedAt,
	)
	var i Optimization
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}

const createOptimizationRun = `-- name: CreateOptimizationRun :one
INSERT INTO optimization_runs (
  id, optimization_id, provider_id, status, started_at
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, optimization_id, provider_id, status, cost, started_at, ended_at
`

type CreateOptimizationRunParams struct {
	ID             pgtype.UUID
	OptimizationID pgtype.UUID
	ProviderID     pgtype.UUID
	Status         OptimizationStatus
	StartedAt      pgtype.Timestamp
}

func (q *Queries) CreateOptimizationRun(ctx context.Context, arg CreateOptimizationRunParams) (OptimizationRun, error) {
	row := q.db.QueryRow(ctx, createOptimizationRun,
		arg.ID,
		arg.OptimizationID,
		arg.ProviderID,
		arg.Status,
		arg.StartedAt,
	)
	var i OptimizationRun
	err := row.Scan(
		&i.ID,
		&i.OptimizationID,
		&i.ProviderID,
		&i.Status,
		&i.Cost,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const createProvider = `-- name: CreateProvider :one

INSERT INTO providers (
  id, name, created_at
) VALUES (
  $1, $2, $3
) RETURNING id, name, created_at, modified_at, deleted_at
`

type CreateProviderParams struct {
	ID        pgtype.UUID
	Name      string
	CreatedAt pgtype.Timestamp
}

// Providers
func (q *Queries) CreateProvider(ctx context.Context, arg CreateProviderParams) (ModelProvider, error) {
	row := q.db.QueryRow(ctx, createProvider, arg.ID, arg.Name, arg.CreatedAt)
	var i ModelProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProviderAccessMethod = `-- name: CreateProviderAccessMethod :one
INSERT INTO provider_access_methods (
  id, provider_id, communication_method, url, created_at
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, provider_id, communication_method, url, created_at, modified_at, deleted_at
`

type CreateProviderAccessMethodParams struct {
	ID                  pgtype.UUID
	ProviderID          pgtype.UUID
	CommunicationMethod CommunicationMethod
	Url                 string
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) CreateProviderAccessMethod(ctx context.Context, arg CreateProviderAccessMethodParams) (ProviderAccessMethod, error) {
	row := q.db.QueryRow(ctx, createProviderAccessMethod,
		arg.ID,
		arg.ProviderID,
		arg.CommunicationMethod,
		arg.Url,
		arg.CreatedAt,
	)
	var i ProviderAccessMethod
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.CommunicationMethod,
		&i.Url,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProviderConstraint = `-- name: CreateProviderConstraint :one
INSERT INTO provider_constraints (
  id, provider_id, max_waypoints_per_request
) VALUES (
  $1, $2, $3
) RETURNING id, provider_id, max_waypoints_per_request, modified_at
`

type CreateProviderConstraintParams struct {
	ID                     pgtype.UUID
	ProviderID             pgtype.UUID
	MaxWaypointsPerRequest int32
}

func (q *Queries) CreateProviderConstraint(ctx context.Context, arg CreateProviderConstraintParams) (ProviderConstraint, error) {
	row := q.db.QueryRow(ctx, createProviderConstraint, arg.ID, arg.ProviderID, arg.MaxWaypointsPerRequest)
	var i ProviderConstraint
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.MaxWaypointsPerRequest,
		&i.ModifiedAt,
	)
	return i, err
}

const createProviderFeature = `-- name: CreateProviderFeature :one
INSERT INTO provider_features (
  id, provider_id, supports_async_operations
) VALUES (
  $1, $2, $3
) RETURNING id, provider_id, supports_async_operations, modified_at
`

type CreateProviderFeatureParams struct {
	ID                      pgtype.UUID
	ProviderID              pgtype.UUID
	SupportsAsyncOperations bool
}

func (q *Queries) CreateProviderFeature(ctx context.Context, arg CreateProviderFeatureParams) (ProviderFeature, error) {
	row := q.db.QueryRow(ctx, createProviderFeature, arg.ID, arg.ProviderID, arg.SupportsAsyncOperations)
	var i ProviderFeature
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.SupportsAsyncOperations,
		&i.ModifiedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
UPDATE customers
  SET deleted_at = $2
WHERE customers.id = $1
`

type DeleteCustomerParams struct {
	ID        pgtype.UUID
	DeletedAt pgtype.Timestamp
}

func (q *Queries) DeleteCustomer(ctx context.Context, arg DeleteCustomerParams) error {
	_, err := q.db.Exec(ctx, deleteCustomer, arg.ID, arg.DeletedAt)
	return err
}

const deleteProvider = `-- name: DeleteProvider :exec
UPDATE providers AS p
SET
  deleted_at = $2,
  modified_at = $3
WHERE p.id = $1
`

type DeleteProviderParams struct {
	ID         pgtype.UUID
	DeletedAt  pgtype.Timestamp
	ModifiedAt pgtype.Timestamp
}

func (q *Queries) DeleteProvider(ctx context.Context, arg DeleteProviderParams) error {
	_, err := q.db.Exec(ctx, deleteProvider, arg.ID, arg.DeletedAt, arg.ModifiedAt)
	return err
}

const deleteProviderAccessMethod = `-- name: DeleteProviderAccessMethod :exec
UPDATE provider_access_methods AS pam
SET
  deleted_at = $2,
  modified_at = $3
WHERE pam.id = $1
`

type DeleteProviderAccessMethodParams struct {
	ID         pgtype.UUID
	DeletedAt  pgtype.Timestamp
	ModifiedAt pgtype.Timestamp
}

func (q *Queries) DeleteProviderAccessMethod(ctx context.Context, arg DeleteProviderAccessMethodParams) error {
	_, err := q.db.Exec(ctx, deleteProviderAccessMethod, arg.ID, arg.DeletedAt, arg.ModifiedAt)
	return err
}

const getActiveOptimizationRunsByCustomerID = `-- name: GetActiveOptimizationRunsByCustomerID :many
WITH optimization AS (
  SELECT
    o.id
  FROM optimizations AS o
  WHERE o.customer_id = $1
)
SELECT
  optr.id, optr.optimization_id, optr.provider_id, optr.status, optr.cost, optr.started_at, optr.ended_at
FROM optimization_runs AS optr
JOIN optimization AS o
  ON optr.optimization_id = o.id
WHERE optr.ended_at IS NULL
ORDER BY optr.started_at DESC
`

type GetActiveOptimizationRunsByCustomerIDRow struct {
	OptimizationRun OptimizationRun
}

func (q *Queries) GetActiveOptimizationRunsByCustomerID(ctx context.Context, customerID pgtype.UUID) ([]GetActiveOptimizationRunsByCustomerIDRow, error) {
	rows, err := q.db.Query(ctx, getActiveOptimizationRunsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveOptimizationRunsByCustomerIDRow{}
	for rows.Next() {
		var i GetActiveOptimizationRunsByCustomerIDRow
		if err := rows.Scan(
			&i.OptimizationRun.ID,
			&i.OptimizationRun.OptimizationID,
			&i.OptimizationRun.ProviderID,
			&i.OptimizationRun.Status,
			&i.OptimizationRun.Cost,
			&i.OptimizationRun.StartedAt,
			&i.OptimizationRun.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveProviderAccessMethodsByProviderID = `-- name: GetActiveProviderAccessMethodsByProviderID :many
SELECT
  pam.id, pam.provider_id, pam.communication_method, pam.url, pam.created_at, pam.modified_at, pam.deleted_at
FROM provider_access_methods AS pam
WHERE (pam.provider_id, pam.deleted_at) = ($1, NULL)
ORDER BY pam.created_at ASC
`

type GetActiveProviderAccessMethodsByProviderIDRow struct {
	ProviderAccessMethod ProviderAccessMethod
}

func (q *Queries) GetActiveProviderAccessMethodsByProviderID(ctx context.Context, providerID pgtype.UUID) ([]GetActiveProviderAccessMethodsByProviderIDRow, error) {
	rows, err := q.db.Query(ctx, getActiveProviderAccessMethodsByProviderID, providerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveProviderAccessMethodsByProviderIDRow{}
	for rows.Next() {
		var i GetActiveProviderAccessMethodsByProviderIDRow
		if err := rows.Scan(
			&i.ProviderAccessMethod.ID,
			&i.ProviderAccessMethod.ProviderID,
			&i.ProviderAccessMethod.CommunicationMethod,
			&i.ProviderAccessMethod.Url,
			&i.ProviderAccessMethod.CreatedAt,
			&i.ProviderAccessMethod.ModifiedAt,
			&i.ProviderAccessMethod.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveProviders = `-- name: GetActiveProviders :many
SELECT
  p.id, p.name, p.created_at, p.modified_at, p.deleted_at
FROM providers AS p
WHERE p.deleted_at IS NULL
ORDER BY p.name ASC
`

type GetActiveProvidersRow struct {
	ModelProvider ModelProvider
}

func (q *Queries) GetActiveProviders(ctx context.Context) ([]GetActiveProvidersRow, error) {
	rows, err := q.db.Query(ctx, getActiveProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveProvidersRow{}
	for rows.Next() {
		var i GetActiveProvidersRow
		if err := rows.Scan(
			&i.ModelProvider.ID,
			&i.ModelProvider.Name,
			&i.ModelProvider.CreatedAt,
			&i.ModelProvider.ModifiedAt,
			&i.ModelProvider.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProviders = `-- name: GetAllProviders :many
SELECT
  p.id, p.name, p.created_at, p.modified_at, p.deleted_at
FROM providers AS p
ORDER BY p.name ASC
`

type GetAllProvidersRow struct {
	ModelProvider ModelProvider
}

func (q *Queries) GetAllProviders(ctx context.Context) ([]GetAllProvidersRow, error) {
	rows, err := q.db.Query(ctx, getAllProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProvidersRow{}
	for rows.Next() {
		var i GetAllProvidersRow
		if err := rows.Scan(
			&i.ModelProvider.ID,
			&i.ModelProvider.Name,
			&i.ModelProvider.CreatedAt,
			&i.ModelProvider.ModifiedAt,
			&i.ModelProvider.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByApiKey = `-- name: GetCustomerByApiKey :one
SELECT
  c.id, c.name, c.business_identifier, c.created_at, c.modified_at, c.deleted_at
FROM customers AS c
JOIN api_keys AS ak
  ON c.id = ak.customer_id
WHERE ak.key_hash = $1
LIMIT 1
`

type GetCustomerByApiKeyRow struct {
	ModelCustomer ModelCustomer
}

func (q *Queries) GetCustomerByApiKey(ctx context.Context, keyHash string) (GetCustomerByApiKeyRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByApiKey, keyHash)
	var i GetCustomerByApiKeyRow
	err := row.Scan(
		&i.ModelCustomer.ID,
		&i.ModelCustomer.Name,
		&i.ModelCustomer.BusinessIdentifier,
		&i.ModelCustomer.CreatedAt,
		&i.ModelCustomer.ModifiedAt,
		&i.ModelCustomer.DeletedAt,
	)
	return i, err
}

const getCustomerByBusinessIdentifier = `-- name: GetCustomerByBusinessIdentifier :one
SELECT
  c.id, c.name, c.business_identifier, c.created_at, c.modified_at, c.deleted_at
FROM customers AS c
WHERE c.business_identifier = $1
LIMIT 1
`

type GetCustomerByBusinessIdentifierRow struct {
	ModelCustomer ModelCustomer
}

func (q *Queries) GetCustomerByBusinessIdentifier(ctx context.Context, businessIdentifier string) (GetCustomerByBusinessIdentifierRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByBusinessIdentifier, businessIdentifier)
	var i GetCustomerByBusinessIdentifierRow
	err := row.Scan(
		&i.ModelCustomer.ID,
		&i.ModelCustomer.Name,
		&i.ModelCustomer.BusinessIdentifier,
		&i.ModelCustomer.CreatedAt,
		&i.ModelCustomer.ModifiedAt,
		&i.ModelCustomer.DeletedAt,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT
  c.id, c.name, c.business_identifier, c.created_at, c.modified_at, c.deleted_at
FROM customers AS c
WHERE c.id = $1
LIMIT 1
`

type GetCustomerByIDRow struct {
	ModelCustomer ModelCustomer
}

func (q *Queries) GetCustomerByID(ctx context.Context, id pgtype.UUID) (GetCustomerByIDRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, id)
	var i GetCustomerByIDRow
	err := row.Scan(
		&i.ModelCustomer.ID,
		&i.ModelCustomer.Name,
		&i.ModelCustomer.BusinessIdentifier,
		&i.ModelCustomer.CreatedAt,
		&i.ModelCustomer.ModifiedAt,
		&i.ModelCustomer.DeletedAt,
	)
	return i, err
}

const getLastUsedApiKeyByCustomerID = `-- name: GetLastUsedApiKeyByCustomerID :one
SELECT
  ak.id, ak.customer_id, ak.key_hash, ak.revoked_at, ak.last_used_at, ak.created_at
FROM api_keys AS ak
WHERE (ak.customer_id, ak.revoked_at) = ($1, NULL)
ORDER BY ak.last_used_at DESC NULLS LAST
LIMIT 1
`

type GetLastUsedApiKeyByCustomerIDRow struct {
	ModelApiKey ModelApiKey
}

func (q *Queries) GetLastUsedApiKeyByCustomerID(ctx context.Context, customerID pgtype.UUID) (GetLastUsedApiKeyByCustomerIDRow, error) {
	row := q.db.QueryRow(ctx, getLastUsedApiKeyByCustomerID, customerID)
	var i GetLastUsedApiKeyByCustomerIDRow
	err := row.Scan(
		&i.ModelApiKey.ID,
		&i.ModelApiKey.CustomerID,
		&i.ModelApiKey.KeyHash,
		&i.ModelApiKey.RevokedAt,
		&i.ModelApiKey.LastUsedAt,
		&i.ModelApiKey.CreatedAt,
	)
	return i, err
}

const getMostRecentApiKeyByCustomerID = `-- name: GetMostRecentApiKeyByCustomerID :one
SELECT
  ak.id, ak.customer_id, ak.key_hash, ak.revoked_at, ak.last_used_at, ak.created_at
FROM api_keys AS ak
WHERE (ak.customer_id, ak.revoked_at) = ($1, NULL)
ORDER BY ak.created_at DESC
LIMIT 1
`

type GetMostRecentApiKeyByCustomerIDRow struct {
	ModelApiKey ModelApiKey
}

func (q *Queries) GetMostRecentApiKeyByCustomerID(ctx context.Context, customerID pgtype.UUID) (GetMostRecentApiKeyByCustomerIDRow, error) {
	row := q.db.QueryRow(ctx, getMostRecentApiKeyByCustomerID, customerID)
	var i GetMostRecentApiKeyByCustomerIDRow
	err := row.Scan(
		&i.ModelApiKey.ID,
		&i.ModelApiKey.CustomerID,
		&i.ModelApiKey.KeyHash,
		&i.ModelApiKey.RevokedAt,
		&i.ModelApiKey.LastUsedAt,
		&i.ModelApiKey.CreatedAt,
	)
	return i, err
}

const getOptimizationByID = `-- name: GetOptimizationByID :one
SELECT
  o.id, o.customer_id, o.kind, o.created_at
FROM optimizations AS o
WHERE o.id = $1
LIMIT 1
`

type GetOptimizationByIDRow struct {
	Optimization Optimization
}

func (q *Queries) GetOptimizationByID(ctx context.Context, id pgtype.UUID) (GetOptimizationByIDRow, error) {
	row := q.db.QueryRow(ctx, getOptimizationByID, id)
	var i GetOptimizationByIDRow
	err := row.Scan(
		&i.Optimization.ID,
		&i.Optimization.CustomerID,
		&i.Optimization.Kind,
		&i.Optimization.CreatedAt,
	)
	return i, err
}

const getProviderByID = `-- name: GetProviderByID :one
SELECT
  p.id, p.name, p.created_at, p.modified_at, p.deleted_at
FROM providers AS p
WHERE p.id = $1
LIMIT 1
`

type GetProviderByIDRow struct {
	ModelProvider ModelProvider
}

func (q *Queries) GetProviderByID(ctx context.Context, id pgtype.UUID) (GetProviderByIDRow, error) {
	row := q.db.QueryRow(ctx, getProviderByID, id)
	var i GetProviderByIDRow
	err := row.Scan(
		&i.ModelProvider.ID,
		&i.ModelProvider.Name,
		&i.ModelProvider.CreatedAt,
		&i.ModelProvider.ModifiedAt,
		&i.ModelProvider.DeletedAt,
	)
	return i, err
}

const getProviderConstraintByProviderID = `-- name: GetProviderConstraintByProviderID :one
SELECT
  pc.id, pc.provider_id, pc.max_waypoints_per_request, pc.modified_at
FROM provider_constraints AS pc
WHERE pc.provider_id = $1
LIMIT 1
`

type GetProviderConstraintByProviderIDRow struct {
	ProviderConstraint ProviderConstraint
}

func (q *Queries) GetProviderConstraintByProviderID(ctx context.Context, providerID pgtype.UUID) (GetProviderConstraintByProviderIDRow, error) {
	row := q.db.QueryRow(ctx, getProviderConstraintByProviderID, providerID)
	var i GetProviderConstraintByProviderIDRow
	err := row.Scan(
		&i.ProviderConstraint.ID,
		&i.ProviderConstraint.ProviderID,
		&i.ProviderConstraint.MaxWaypointsPerRequest,
		&i.ProviderConstraint.ModifiedAt,
	)
	return i, err
}

const getProviderDetailsByProviderID = `-- name: GetProviderDetailsByProviderID :one
SELECT
  p.id, p.name, p.created_at, p.modified_at, p.deleted_at,
  pc.id, pc.provider_id, pc.max_waypoints_per_request, pc.modified_at,
  pf.id, pf.provider_id, pf.supports_async_operations, pf.modified_at
FROM providers AS p
LEFT JOIN provider_constraints AS pc
  ON p.id = pc.provider_id
LEFT JOIN provider_features AS pf
  ON p.id = pf.provider_id
WHERE p.id = $1
LIMIT 1
`

type GetProviderDetailsByProviderIDRow struct {
	ModelProvider      ModelProvider
	ProviderConstraint ProviderConstraint
	ProviderFeature    ProviderFeature
}

func (q *Queries) GetProviderDetailsByProviderID(ctx context.Context, id pgtype.UUID) (GetProviderDetailsByProviderIDRow, error) {
	row := q.db.QueryRow(ctx, getProviderDetailsByProviderID, id)
	var i GetProviderDetailsByProviderIDRow
	err := row.Scan(
		&i.ModelProvider.ID,
		&i.ModelProvider.Name,
		&i.ModelProvider.CreatedAt,
		&i.ModelProvider.ModifiedAt,
		&i.ModelProvider.DeletedAt,
		&i.ProviderConstraint.ID,
		&i.ProviderConstraint.ProviderID,
		&i.ProviderConstraint.MaxWaypointsPerRequest,
		&i.ProviderConstraint.ModifiedAt,
		&i.ProviderFeature.ID,
		&i.ProviderFeature.ProviderID,
		&i.ProviderFeature.SupportsAsyncOperations,
		&i.ProviderFeature.ModifiedAt,
	)
	return i, err
}

const revokeAllApiKeysByCustomerID = `-- name: RevokeAllApiKeysByCustomerID :exec
UPDATE api_keys AS ak
SET
  revoked_at = $2
WHERE ak.customer_id = $1
`

type RevokeAllApiKeysByCustomerIDParams struct {
	CustomerID pgtype.UUID
	RevokedAt  pgtype.Timestamp
}

func (q *Queries) RevokeAllApiKeysByCustomerID(ctx context.Context, arg RevokeAllApiKeysByCustomerIDParams) error {
	_, err := q.db.Exec(ctx, revokeAllApiKeysByCustomerID, arg.CustomerID, arg.RevokedAt)
	return err
}

const revokeApiKey = `-- name: RevokeApiKey :exec
UPDATE api_keys AS ak
SET
	revoked_at = $2
WHERE ak.id = $1
`

type RevokeApiKeyParams struct {
	ID        pgtype.UUID
	RevokedAt pgtype.Timestamp
}

func (q *Queries) RevokeApiKey(ctx context.Context, arg RevokeApiKeyParams) error {
	_, err := q.db.Exec(ctx, revokeApiKey, arg.ID, arg.RevokedAt)
	return err
}

const setApiKeyLastUsedAt = `-- name: SetApiKeyLastUsedAt :exec
UPDATE api_keys AS ak
SET
	last_used_at = $2
WHERE ak.id = $1
`

type SetApiKeyLastUsedAtParams struct {
	ID         pgtype.UUID
	LastUsedAt pgtype.Timestamp
}

func (q *Queries) SetApiKeyLastUsedAt(ctx context.Context, arg SetApiKeyLastUsedAtParams) error {
	_, err := q.db.Exec(ctx, setApiKeyLastUsedAt, arg.ID, arg.LastUsedAt)
	return err
}

const updateOptimizationRun = `-- name: UpdateOptimizationRun :exec
UPDATE optimization_runs AS optr
SET
  status = $2,
  cost = $3,
  ended_at = $4
WHERE optr.id = $1
`

type UpdateOptimizationRunParams struct {
	ID      pgtype.UUID
	Status  OptimizationStatus
	Cost    pgtype.Numeric
	EndedAt pgtype.Timestamp
}

func (q *Queries) UpdateOptimizationRun(ctx context.Context, arg UpdateOptimizationRunParams) error {
	_, err := q.db.Exec(ctx, updateOptimizationRun,
		arg.ID,
		arg.Status,
		arg.Cost,
		arg.EndedAt,
	)
	return err
}

const updateProvider = `-- name: UpdateProvider :exec
UPDATE providers AS p
SET
  name = $2,
  modified_at = $3
WHERE p.id = $1
`

type UpdateProviderParams struct {
	ID         pgtype.UUID
	Name       string
	ModifiedAt pgtype.Timestamp
}

func (q *Queries) UpdateProvider(ctx context.Context, arg UpdateProviderParams) error {
	_, err := q.db.Exec(ctx, updateProvider, arg.ID, arg.Name, arg.ModifiedAt)
	return err
}

const updateProviderAccessMethod = `-- name: UpdateProviderAccessMethod :exec
UPDATE provider_access_methods AS pam
SET
  communication_method = $2,
  url = $3,
  modified_at = $4
WHERE pam.id = $1
`

type UpdateProviderAccessMethodParams struct {
	ID                  pgtype.UUID
	CommunicationMethod CommunicationMethod
	Url                 string
	ModifiedAt          pgtype.Timestamp
}

func (q *Queries) UpdateProviderAccessMethod(ctx context.Context, arg UpdateProviderAccessMethodParams) error {
	_, err := q.db.Exec(ctx, updateProviderAccessMethod,
		arg.ID,
		arg.CommunicationMethod,
		arg.Url,
		arg.ModifiedAt,
	)
	return err
}

const updateProviderConstraint = `-- name: UpdateProviderConstraint :exec
UPDATE provider_constraints AS pc
SET
  max_waypoints_per_request = $2,
  modified_at = $3
WHERE pc.id = $1
`

type UpdateProviderConstraintParams struct {
	ID                     pgtype.UUID
	MaxWaypointsPerRequest int32
	ModifiedAt             pgtype.Timestamp
}

func (q *Queries) UpdateProviderConstraint(ctx context.Context, arg UpdateProviderConstraintParams) error {
	_, err := q.db.Exec(ctx, updateProviderConstraint, arg.ID, arg.MaxWaypointsPerRequest, arg.ModifiedAt)
	return err
}

const updateProviderFeature = `-- name: UpdateProviderFeature :exec
UPDATE provider_features AS pf
SET
  supports_async_operations = $2,
  modified_at = $3
WHERE pf.id = $1
`

type UpdateProviderFeatureParams struct {
	ID                      pgtype.UUID
	SupportsAsyncOperations bool
	ModifiedAt              pgtype.Timestamp
}

func (q *Queries) UpdateProviderFeature(ctx context.Context, arg UpdateProviderFeatureParams) error {
	_, err := q.db.Exec(ctx, updateProviderFeature, arg.ID, arg.SupportsAsyncOperations, arg.ModifiedAt)
	return err
}
