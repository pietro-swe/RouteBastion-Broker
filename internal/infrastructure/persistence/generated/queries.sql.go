// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	go_uuid "github.com/satori/go.uuid"
)

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO api_keys (
  id, key, customer_id, created_at
) VALUES (
  $1, $2, $3, $4
) RETURNING id, key, customer_id, created_at, modified_at, deleted_at
`

type CreateApiKeyParams struct {
	ID         go_uuid.UUID
	Key        string
	CustomerID go_uuid.UUID
	CreatedAt  pgtype.Timestamp
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ModelApiKey, error) {
	row := q.db.QueryRow(ctx, createApiKey,
		arg.ID,
		arg.Key,
		arg.CustomerID,
		arg.CreatedAt,
	)
	var i ModelApiKey
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.CustomerID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  id, name, business_identifier
) VALUES (
  $1, $2, $3
) RETURNING id, name, business_identifier, created_at, modified_at, deleted_at
`

type CreateCustomerParams struct {
	ID                 go_uuid.UUID
	Name               string
	BusinessIdentifier string
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (ModelCustomer, error) {
	row := q.db.QueryRow(ctx, createCustomer, arg.ID, arg.Name, arg.BusinessIdentifier)
	var i ModelCustomer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BusinessIdentifier,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles (
  id,
  plate,
  capacity,
  cargo_type,
  customer_id,
  created_at
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, plate, capacity, cargo_type, customer_id, created_at, modified_at, deleted_at
`

type CreateVehicleParams struct {
	ID         go_uuid.UUID
	Plate      string
	Capacity   float64
	CargoType  CargoKind
	CustomerID go_uuid.UUID
	CreatedAt  pgtype.Timestamp
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (ModelVehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.ID,
		arg.Plate,
		arg.Capacity,
		arg.CargoType,
		arg.CustomerID,
		arg.CreatedAt,
	)
	var i ModelVehicle
	err := row.Scan(
		&i.ID,
		&i.Plate,
		&i.Capacity,
		&i.CargoType,
		&i.CustomerID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
UPDATE api_keys
SET
	modified_at = $2,
	deleted_at = $3
WHERE id = $1
`

type DeleteApiKeyParams struct {
	ID         go_uuid.UUID
	ModifiedAt pgtype.Timestamp
	DeletedAt  pgtype.Timestamp
}

func (q *Queries) DeleteApiKey(ctx context.Context, arg DeleteApiKeyParams) error {
	_, err := q.db.Exec(ctx, deleteApiKey, arg.ID, arg.ModifiedAt, arg.DeletedAt)
	return err
}

const deleteConstraint = `-- name: DeleteConstraint :exec
UPDATE constraints
  SET deleted_at = $2
WHERE constraints.id = $1
`

type DeleteConstraintParams struct {
	ID        go_uuid.UUID
	DeletedAt pgtype.Timestamp
}

func (q *Queries) DeleteConstraint(ctx context.Context, arg DeleteConstraintParams) error {
	_, err := q.db.Exec(ctx, deleteConstraint, arg.ID, arg.DeletedAt)
	return err
}

const deleteVehicle = `-- name: DeleteVehicle :exec
UPDATE vehicles
  SET deleted_at = $2
WHERE vehicles.id = $1
`

type DeleteVehicleParams struct {
	ID        go_uuid.UUID
	DeletedAt pgtype.Timestamp
}

func (q *Queries) DeleteVehicle(ctx context.Context, arg DeleteVehicleParams) error {
	_, err := q.db.Exec(ctx, deleteVehicle, arg.ID, arg.DeletedAt)
	return err
}

const disableCustomer = `-- name: DisableCustomer :exec
UPDATE customers
  SET deleted_at = $2
WHERE customers.id = $1
`

type DisableCustomerParams struct {
	ID        go_uuid.UUID
	DeletedAt pgtype.Timestamp
}

func (q *Queries) DisableCustomer(ctx context.Context, arg DisableCustomerParams) error {
	_, err := q.db.Exec(ctx, disableCustomer, arg.ID, arg.DeletedAt)
	return err
}

const getActiveOptimizationsByCustomerID = `-- name: GetActiveOptimizationsByCustomerID :many
SELECT
  optimizations.id, optimizations.customer_id, optimizations.selected_cloud_id, optimizations.status, optimizations.kind, optimizations.cost, optimizations.started_at, optimizations.ended_at, optimizations.created_at, optimizations.modified_at,
  optimization_waypoints.id, optimization_waypoints.optimization_id, optimization_waypoints.latitude, optimization_waypoints.longitude,
  optimization_vehicles.optimization_id, optimization_vehicles.vehicle_id
FROM optimizations
  INNER JOIN optimization_waypoints ON optimizations.id = optimization_waypoints.optimization_id
  INNER JOIN optimization_vehicles ON optimizations.id = optimization_vehicles.optimization_id
WHERE (optimizations.customer_id, optimizations.ended_at) = ($1, NULL)
ORDER BY optimizations.created_at DESC
`

type GetActiveOptimizationsByCustomerIDRow struct {
	ModelOptimization         ModelOptimization
	ModelOptimizationWaypoint ModelOptimizationWaypoint
	ModelOptimizationVehicle  ModelOptimizationVehicle
}

func (q *Queries) GetActiveOptimizationsByCustomerID(ctx context.Context, customerID go_uuid.UUID) ([]GetActiveOptimizationsByCustomerIDRow, error) {
	rows, err := q.db.Query(ctx, getActiveOptimizationsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveOptimizationsByCustomerIDRow{}
	for rows.Next() {
		var i GetActiveOptimizationsByCustomerIDRow
		if err := rows.Scan(
			&i.ModelOptimization.ID,
			&i.ModelOptimization.CustomerID,
			&i.ModelOptimization.SelectedCloudID,
			&i.ModelOptimization.Status,
			&i.ModelOptimization.Kind,
			&i.ModelOptimization.Cost,
			&i.ModelOptimization.StartedAt,
			&i.ModelOptimization.EndedAt,
			&i.ModelOptimization.CreatedAt,
			&i.ModelOptimization.ModifiedAt,
			&i.ModelOptimizationWaypoint.ID,
			&i.ModelOptimizationWaypoint.OptimizationID,
			&i.ModelOptimizationWaypoint.Latitude,
			&i.ModelOptimizationWaypoint.Longitude,
			&i.ModelOptimizationVehicle.OptimizationID,
			&i.ModelOptimizationVehicle.VehicleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeyByCustomerID = `-- name: GetApiKeyByCustomerID :one
SELECT
  ak.id,
  ak.key,
  ak.customer_id,
  ak.created_at,
  ak.modified_at,
  ak.deleted_at
FROM api_keys AS ak
WHERE (ak.customer_id, ak.deleted_at) = ($1, NULL)
ORDER BY ak.created_at DESC
LIMIT 1
`

func (q *Queries) GetApiKeyByCustomerID(ctx context.Context, customerID go_uuid.UUID) (ModelApiKey, error) {
	row := q.db.QueryRow(ctx, getApiKeyByCustomerID, customerID)
	var i ModelApiKey
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.CustomerID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAvailableProviders = `-- name: GetAvailableProviders :many
SELECT
  providers.id, providers.name, providers.created_at, providers.modified_at, providers.deleted_at,
  provider_communication.id, provider_communication.provider_id, provider_communication.accessible_with, provider_communication.url, provider_communication.created_at, provider_communication.modified_at, provider_communication.deleted_at,
  provider_constraints_and_features.id, provider_constraints_and_features.provider_id, provider_constraints_and_features.max_waypoints, provider_constraints_and_features.supports_async_batch_requests
FROM providers
  JOIN provider_communication ON providers.id = provider_communication.provider_id
  JOIN provider_constraints_and_features ON providers.id = provider_constraints_and_features.provider_id
WHERE providers.deleted_at IS NULL
ORDER BY providers.name ASC
`

type GetAvailableProvidersRow struct {
	ModelProvider                       ModelProvider
	ModelProviderCommunication          ModelProviderCommunication
	ModelProviderConstraintsAndFeatures ModelProviderConstraintsAndFeatures
}

func (q *Queries) GetAvailableProviders(ctx context.Context) ([]GetAvailableProvidersRow, error) {
	rows, err := q.db.Query(ctx, getAvailableProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableProvidersRow{}
	for rows.Next() {
		var i GetAvailableProvidersRow
		if err := rows.Scan(
			&i.ModelProvider.ID,
			&i.ModelProvider.Name,
			&i.ModelProvider.CreatedAt,
			&i.ModelProvider.ModifiedAt,
			&i.ModelProvider.DeletedAt,
			&i.ModelProviderCommunication.ID,
			&i.ModelProviderCommunication.ProviderID,
			&i.ModelProviderCommunication.AccessibleWith,
			&i.ModelProviderCommunication.Url,
			&i.ModelProviderCommunication.CreatedAt,
			&i.ModelProviderCommunication.ModifiedAt,
			&i.ModelProviderCommunication.DeletedAt,
			&i.ModelProviderConstraintsAndFeatures.ID,
			&i.ModelProviderConstraintsAndFeatures.ProviderID,
			&i.ModelProviderConstraintsAndFeatures.MaxWaypoints,
			&i.ModelProviderConstraintsAndFeatures.SupportsAsyncBatchRequests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConstraintsByCustomerID = `-- name: GetConstraintsByCustomerID :many
SELECT
  c.id,
  c.customer_id,
  c.kind,
  c.value,
  c.created_at,
  c.modified_at,
  c.deleted_at
FROM constraints AS c
WHERE (c.customer_id, c.deleted_at) = ($1, NULL)
`

func (q *Queries) GetConstraintsByCustomerID(ctx context.Context, customerID go_uuid.UUID) ([]Constraint, error) {
	rows, err := q.db.Query(ctx, getConstraintsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Constraint{}
	for rows.Next() {
		var i Constraint
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Kind,
			&i.Value,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByApiKey = `-- name: GetCustomerByApiKey :one
SELECT
  c.id, c.name, c.business_identifier, c.created_at, c.modified_at, c.deleted_at,
  ak.id, ak.key, ak.customer_id, ak.created_at, ak.modified_at, ak.deleted_at
FROM customers AS c
JOIN api_keys AS ak
  ON c.id = ak.customer_id
WHERE ak.key = $1
LIMIT 1
`

type GetCustomerByApiKeyRow struct {
	ModelCustomer ModelCustomer
	ModelApiKey   ModelApiKey
}

func (q *Queries) GetCustomerByApiKey(ctx context.Context, key string) (GetCustomerByApiKeyRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByApiKey, key)
	var i GetCustomerByApiKeyRow
	err := row.Scan(
		&i.ModelCustomer.ID,
		&i.ModelCustomer.Name,
		&i.ModelCustomer.BusinessIdentifier,
		&i.ModelCustomer.CreatedAt,
		&i.ModelCustomer.ModifiedAt,
		&i.ModelCustomer.DeletedAt,
		&i.ModelApiKey.ID,
		&i.ModelApiKey.Key,
		&i.ModelApiKey.CustomerID,
		&i.ModelApiKey.CreatedAt,
		&i.ModelApiKey.ModifiedAt,
		&i.ModelApiKey.DeletedAt,
	)
	return i, err
}

const getManyVehiclesByCustomerID = `-- name: GetManyVehiclesByCustomerID :many
SELECT
  v.id,
  v.plate,
  v.capacity,
  v.cargo_type,
  v.customer_id,
  v.created_at,
  v.modified_at,
  v.deleted_at
FROM vehicles AS v
WHERE (v.customer_id, v.deleted_at) = ($1, NULL)
`

func (q *Queries) GetManyVehiclesByCustomerID(ctx context.Context, customerID go_uuid.UUID) ([]ModelVehicle, error) {
	rows, err := q.db.Query(ctx, getManyVehiclesByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModelVehicle{}
	for rows.Next() {
		var i ModelVehicle
		if err := rows.Scan(
			&i.ID,
			&i.Plate,
			&i.Capacity,
			&i.CargoType,
			&i.CustomerID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneCustomerByBusinessIdentifier = `-- name: GetOneCustomerByBusinessIdentifier :one
SELECT
  c.id, c.name, c.business_identifier, c.created_at, c.modified_at, c.deleted_at,
  ak.id, ak.key, ak.customer_id, ak.created_at, ak.modified_at, ak.deleted_at
FROM customers AS c
JOIN api_keys AS ak
  ON c.id = ak.customer_id
WHERE c.business_identifier = $1
LIMIT 1
`

type GetOneCustomerByBusinessIdentifierRow struct {
	ModelCustomer ModelCustomer
	ModelApiKey   ModelApiKey
}

func (q *Queries) GetOneCustomerByBusinessIdentifier(ctx context.Context, businessIdentifier string) (GetOneCustomerByBusinessIdentifierRow, error) {
	row := q.db.QueryRow(ctx, getOneCustomerByBusinessIdentifier, businessIdentifier)
	var i GetOneCustomerByBusinessIdentifierRow
	err := row.Scan(
		&i.ModelCustomer.ID,
		&i.ModelCustomer.Name,
		&i.ModelCustomer.BusinessIdentifier,
		&i.ModelCustomer.CreatedAt,
		&i.ModelCustomer.ModifiedAt,
		&i.ModelCustomer.DeletedAt,
		&i.ModelApiKey.ID,
		&i.ModelApiKey.Key,
		&i.ModelApiKey.CustomerID,
		&i.ModelApiKey.CreatedAt,
		&i.ModelApiKey.ModifiedAt,
		&i.ModelApiKey.DeletedAt,
	)
	return i, err
}

const getOptimizationHistoryByCustomerID = `-- name: GetOptimizationHistoryByCustomerID :many
SELECT
  optimizations.id, optimizations.customer_id, optimizations.selected_cloud_id, optimizations.status, optimizations.kind, optimizations.cost, optimizations.started_at, optimizations.ended_at, optimizations.created_at, optimizations.modified_at,
  optimization_waypoints.id, optimization_waypoints.optimization_id, optimization_waypoints.latitude, optimization_waypoints.longitude,
  optimization_vehicles.optimization_id, optimization_vehicles.vehicle_id
FROM optimizations
  INNER JOIN optimization_waypoints ON optimizations.id = optimization_waypoints.optimization_id
  INNER JOIN optimization_vehicles ON optimizations.id = optimization_vehicles.optimization_id
WHERE optimizations.customer_id = $1
ORDER BY optimizations.created_at DESC
`

type GetOptimizationHistoryByCustomerIDRow struct {
	ModelOptimization         ModelOptimization
	ModelOptimizationWaypoint ModelOptimizationWaypoint
	ModelOptimizationVehicle  ModelOptimizationVehicle
}

func (q *Queries) GetOptimizationHistoryByCustomerID(ctx context.Context, customerID go_uuid.UUID) ([]GetOptimizationHistoryByCustomerIDRow, error) {
	rows, err := q.db.Query(ctx, getOptimizationHistoryByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptimizationHistoryByCustomerIDRow{}
	for rows.Next() {
		var i GetOptimizationHistoryByCustomerIDRow
		if err := rows.Scan(
			&i.ModelOptimization.ID,
			&i.ModelOptimization.CustomerID,
			&i.ModelOptimization.SelectedCloudID,
			&i.ModelOptimization.Status,
			&i.ModelOptimization.Kind,
			&i.ModelOptimization.Cost,
			&i.ModelOptimization.StartedAt,
			&i.ModelOptimization.EndedAt,
			&i.ModelOptimization.CreatedAt,
			&i.ModelOptimization.ModifiedAt,
			&i.ModelOptimizationWaypoint.ID,
			&i.ModelOptimizationWaypoint.OptimizationID,
			&i.ModelOptimizationWaypoint.Latitude,
			&i.ModelOptimizationWaypoint.Longitude,
			&i.ModelOptimizationVehicle.OptimizationID,
			&i.ModelOptimizationVehicle.VehicleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviderDetailsByID = `-- name: GetProviderDetailsByID :one
SELECT
	providers.id, providers.name, providers.created_at, providers.modified_at, providers.deleted_at,
  provider_communication.id, provider_communication.provider_id, provider_communication.accessible_with, provider_communication.url, provider_communication.created_at, provider_communication.modified_at, provider_communication.deleted_at,
  provider_constraints_and_features.id, provider_constraints_and_features.provider_id, provider_constraints_and_features.max_waypoints, provider_constraints_and_features.supports_async_batch_requests
FROM providers
  JOIN provider_communication ON providers.id = provider_communication.provider_id
  JOIN provider_constraints_and_features ON providers.id = provider_constraints_and_features.provider_id
WHERE providers.id = $1
`

type GetProviderDetailsByIDRow struct {
	ModelProvider                       ModelProvider
	ModelProviderCommunication          ModelProviderCommunication
	ModelProviderConstraintsAndFeatures ModelProviderConstraintsAndFeatures
}

func (q *Queries) GetProviderDetailsByID(ctx context.Context, id go_uuid.UUID) (GetProviderDetailsByIDRow, error) {
	row := q.db.QueryRow(ctx, getProviderDetailsByID, id)
	var i GetProviderDetailsByIDRow
	err := row.Scan(
		&i.ModelProvider.ID,
		&i.ModelProvider.Name,
		&i.ModelProvider.CreatedAt,
		&i.ModelProvider.ModifiedAt,
		&i.ModelProvider.DeletedAt,
		&i.ModelProviderCommunication.ID,
		&i.ModelProviderCommunication.ProviderID,
		&i.ModelProviderCommunication.AccessibleWith,
		&i.ModelProviderCommunication.Url,
		&i.ModelProviderCommunication.CreatedAt,
		&i.ModelProviderCommunication.ModifiedAt,
		&i.ModelProviderCommunication.DeletedAt,
		&i.ModelProviderConstraintsAndFeatures.ID,
		&i.ModelProviderConstraintsAndFeatures.ProviderID,
		&i.ModelProviderConstraintsAndFeatures.MaxWaypoints,
		&i.ModelProviderConstraintsAndFeatures.SupportsAsyncBatchRequests,
	)
	return i, err
}

const insertConstraint = `-- name: InsertConstraint :one
INSERT INTO constraints (
  customer_id, kind, value
) VALUES (
  $1, $2, $3
) RETURNING id, customer_id, kind, value, created_at, modified_at, deleted_at
`

type InsertConstraintParams struct {
	CustomerID go_uuid.UUID
	Kind       ConstraintKind
	Value      []byte
}

func (q *Queries) InsertConstraint(ctx context.Context, arg InsertConstraintParams) (Constraint, error) {
	row := q.db.QueryRow(ctx, insertConstraint, arg.CustomerID, arg.Kind, arg.Value)
	var i Constraint
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Kind,
		&i.Value,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateApiKey = `-- name: UpdateApiKey :exec
UPDATE api_keys
SET
	key = $2,
	modified_at = $3
WHERE id = $1
`

type UpdateApiKeyParams struct {
	ID         go_uuid.UUID
	Key        string
	ModifiedAt pgtype.Timestamp
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) error {
	_, err := q.db.Exec(ctx, updateApiKey, arg.ID, arg.Key, arg.ModifiedAt)
	return err
}

const updateConstraintKindAndValue = `-- name: UpdateConstraintKindAndValue :exec
UPDATE constraints
  SET kind = $2,
    value = $3
WHERE constraints.id = $1
`

type UpdateConstraintKindAndValueParams struct {
	ID    go_uuid.UUID
	Kind  ConstraintKind
	Value []byte
}

func (q *Queries) UpdateConstraintKindAndValue(ctx context.Context, arg UpdateConstraintKindAndValueParams) error {
	_, err := q.db.Exec(ctx, updateConstraintKindAndValue, arg.ID, arg.Kind, arg.Value)
	return err
}

const updateConstraintValue = `-- name: UpdateConstraintValue :exec
UPDATE constraints
  SET value = $2
WHERE constraints.id = $1
`

type UpdateConstraintValueParams struct {
	ID    go_uuid.UUID
	Value []byte
}

func (q *Queries) UpdateConstraintValue(ctx context.Context, arg UpdateConstraintValueParams) error {
	_, err := q.db.Exec(ctx, updateConstraintValue, arg.ID, arg.Value)
	return err
}
